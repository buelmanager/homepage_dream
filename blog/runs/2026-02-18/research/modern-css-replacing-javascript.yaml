topic: "modern-css-replacing-javascript"
researched_at: "2026-02-18T15:30:00+09:00"
queries:
  - query: "modern CSS replacing JavaScript 2025 2026 scroll animations anchor positioning view transitions"
    language: "en"
  - query: "CSS scroll-driven animations vs JavaScript IntersectionObserver performance comparison 2025"
    language: "en"
  - query: "CSS anchor positioning tooltip vs JavaScript bundle size comparison 2025"
    language: "en"
  - query: "CSS grid auto-fill responsive card layout vs JavaScript no media query line count 2025"
    language: "en"
  - query: "Popper.js Floating UI bundle size kilobytes CSS anchor positioning replacement 2025"
    language: "en"
  - query: "GSAP bundle size kilobytes ScrollTrigger weight 2025 performance"
    language: "en"
  - query: "state of CSS 2024 survey results JavaScript usage percentage developer adoption"
    language: "en"
  - query: "CSS anchor positioning browser support 2026 Firefox Safari production ready"
    language: "en"
  - query: "scroll-driven animations performance benchmark main thread GPU compositor vs IntersectionObserver jank"
    language: "en"

findings:
  trends:
    - point: >
        CSS in 2025-2026 has reached a tipping point where it can replace a wide class of
        JavaScript-only patterns: scroll-driven animations (replacing IntersectionObserver and
        GSAP), anchor positioning (replacing Popper.js / Floating UI), carousel navigation
        (replacing custom JS sliders), and responsive grid layouts (replacing JS viewport
        listeners). The overall narrative being adopted by Smashing Magazine, LogRocket, and
        web.dev is "CSS is now doing the work JavaScript had to do."
      source: "https://blog.logrocket.com/css-in-2026/"
    - point: >
        Scroll-driven animations reached cross-browser Baseline as of December 2024 (Chrome 115+,
        Edge 115+) and Interop 2026 confirmed Firefox and Safari are working toward full
        parity. The animation-timeline: scroll() and animation-timeline: view() properties
        let developers build progress bars, reveal-on-scroll effects, and parallax entirely
        in CSS with zero JavaScript.
      source: "https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Scroll-driven_animations"
    - point: >
        CSS Anchor Positioning (Chrome 125+ as of May 2024, Firefox 145+, Safari 26+) has
        become part of Interop 2026, signaling that Chrome, Firefox, and Safari are committed
        to full and consistent support. It natively handles the tooltip/popover positioning
        logic that once required Popper.js or Floating UI, including automatic overflow
        detection and flip-fallback behavior via position-try-fallbacks.
      source: "https://www.medianic.co.uk/2026/02/10/css-features-2026-exciting-updates-from-firefox-and-chrome/"
    - point: >
        The Popover API reached Baseline Widely Available in April 2025 (all major browsers:
        Chrome, Firefox, Safari, Edge). Combined with CSS Anchor Positioning, it enables
        fully accessible tooltip and popover patterns with zero JavaScript, replacing
        patterns that previously required manual focus trapping, aria-expanded toggling, and
        scroll/resize event listeners.
      source: "https://web.dev/blog/popover-api"
    - point: >
        CSS masonry layout (proposed as display: grid-lanes or @grid-lanes display type) is
        actively being implemented by Microsoft (Chromium), Mozilla, and Apple, targeting
        elimination of Masonry.js which is downloaded approximately 200,000 times weekly on
        npm. Smashing Magazine notes the median JS per page has grown to 23 requests (up 8%
        since 2022) and native CSS layout directly counters this bloat.
      source: "https://www.smashingmagazine.com/2025/12/masonry-things-you-wont-need-library-anymore/"
    - point: >
        CSS Scroll State Queries (container-type: scroll-state) allow developers to detect
        whether a sticky element is currently adhered to the viewport without any
        IntersectionObserver or JavaScript. This enables patterns like sticky headers that
        acquire a drop-shadow only when actively stuck — previously requiring a JS observer
        to add/remove a class.
      source: "https://www.smashingmagazine.com/2025/12/state-logic-native-power-css-wrapped-2025/"
    - point: >
        CSS Grid's repeat(auto-fill, minmax()) pattern delivers a fully responsive card grid
        from 1 to N columns in approximately 3-4 lines of CSS without a single @media query.
        This eliminates the JavaScript viewport-resize listener pattern that was common in
        pre-CSS Grid codebases for dynamic column count management.
      source: "https://css-tricks.com/look-ma-no-media-queries-responsive-layouts-using-css-grid/"
    - point: >
        The @starting-style at-rule (cross-browser Baseline in 2025) enables CSS entry/exit
        animations for elements that transition from display: none, removing the need for
        JavaScript timing hacks (setTimeout delays before removing hidden class) that were
        a standard workaround for animated disclosure patterns.
      source: "https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@starting-style"
    - point: >
        The sibling-index() and sibling-count() CSS functions (shipping in 2025-2026) allow
        staggered animation-delay values computed directly from DOM position, removing the
        need to add inline style attributes or generate nth-child rules for each element.
        Pattern previously required JavaScript to calculate and inject delay values per item.
      source: "https://www.southwellmedia.com/blog/css-2026-7-features-that-let-browsers-do-the-work"

  expert_opinions:
    - who: "Kevin Powell (CSS educator, YouTube, 900K+ subscribers)"
      opinion: >
        Demonstrated CSS-only scroll-based animations including true parallax using
        animation-timeline: scroll(), showing that effects previously requiring GSAP or
        custom scroll listeners can now be achieved with pure CSS. His tutorials emphasize
        that these animations run off the main thread and require no dependencies or
        polyfills in Chrome. He frames CSS scroll-driven animations as the practical
        replacement for ScrollReveal and similar libraries for typical homepage use cases.
      source: "https://www.classcentral.com/course/youtube-incredible-scroll-based-animations-with-css-only-275166"
    - who: "Smashing Magazine editorial team"
      opinion: >
        In 'CSS Wrapped 2025', Smashing Magazine declared that CSS is entering an era of
        native state, logic, and UI power that systematically removes JavaScript from common
        UI patterns. Their specific framing: 'The ability to create a fully functional,
        accessible slider without a single line of JavaScript is not just convenient; it is a
        triumph for performance.' They cite scroll markers, scroll buttons, anchor positioning,
        and scroll state queries as the most impactful JavaScript-eliminating additions.
      source: "https://www.smashingmagazine.com/2025/12/state-logic-native-power-css-wrapped-2025/"
    - who: "LogRocket Blog (engineering-focused developer publication)"
      opinion: >
        Framed 2026 CSS as 'about reducing JavaScript, increasing native UI intelligence,
        and building scalable design systems.' Highlighted that CSS can now replace 150+ lines
        of JavaScript with a few CSS declarations in demos using appearance: base-select,
        sibling-index(), and typed attr(). Recommends starting migration with carousels,
        tooltips, and dropdowns as the highest-ROI components.
      source: "https://blog.logrocket.com/css-in-2026/"
    - who: "Chrome for Developers team (Google)"
      opinion: >
        Published a performance case study demonstrating that CSS scroll-driven animations
        are 'completely unaffected by heavy JavaScript work' running concurrently, whereas
        JavaScript-based scroll animations 'become janky and sluggish due to main thread
        resource contention.' The team states the APIs are designed to 'use as few main
        thread resources as possible' making them both easier to implement and smoother than
        scroll event listeners.
      source: "https://developer.chrome.com/blog/scroll-animation-performance-case-study"
    - who: "LearnWebCraft (CSS training platform)"
      opinion: >
        Documented that CSS Anchor Positioning delivers 'zero JS bundle size' for tooltip
        positioning compared to Popper.js or Floating UI. Described the JavaScript alternative
        as requiring event listeners calculating getBoundingClientRect() and resize observers,
        while the CSS version runs 'native speed' on the compositor thread rather than
        triggering main-thread recalculations on every scroll/resize event.
      source: "https://learnwebcraft.com/learn/css/css-anchor-positioning-api-popperjs-replacement"
    - who: "Southwell Media (web agency blog)"
      opinion: >
        Specifically quantified the anchor positioning gain: 'the positioning logic that once
        consumed 200+ lines of JavaScript condenses into four lines of CSS.' Their recommended
        CSS tooltip implementation uses position-anchor, position-area, and
        position-try-fallbacks — three properties — compared to a full JavaScript module
        with scroll listeners, resize observers, and getBoundingClientRect calls.
      source: "https://www.southwellmedia.com/blog/css-2026-7-features-that-let-browsers-do-the-work"
    - who: "OddBird (CSS Working Group contributors)"
      opinion: >
        Confirmed in October 2025 that Anchor Positioning updates include clarifications to
        position-area syntax and increased reliability across browsers. As active contributors
        to the CSS spec, OddBird frames anchor positioning as production-ready for progressive
        enhancement, noting the feature has stabilized significantly from its initial Chrome
        implementation.
      source: "https://www.oddbird.net/2025/10/13/anchor-position-area-update/"

  statistics:
    - stat: >
        State of CSS 2024 survey: 53% of respondents write more JavaScript than CSS in their
        day-to-day work, even in the context of a CSS survey — indicating significant room for
        CSS to reclaim ground currently held by JavaScript in UI pattern implementation.
      source: "https://web.dev/blog/state-of-css-html-2024"
    - stat: >
        State of CSS 2024 survey: The :has() selector ranked as the favorite new CSS feature
        at 36%, with @container (container queries) second at 17%, reflecting strong developer
        interest in CSS features that enable JavaScript-like conditional and context-aware
        behavior.
      source: "https://2024.stateofcss.com/en-US/"
    - stat: >
        Popover API reached Baseline Widely Available status in April 2025, meaning it is
        supported across Chrome, Firefox, Safari, and Edge — enabling zero-JavaScript tooltip
        and modal patterns for 100% of modern browser users.
      source: "https://web.dev/blog/popover-api"
    - stat: >
        CSS Anchor Positioning browser support as of early 2026: Chrome 125+, Edge 125+,
        Opera 111+, Safari 26+, Firefox 145+ (in progress). Now included in Interop 2026
        goals for full cross-browser consistency.
      source: "https://caniuse.com/css-anchor-positioning"
    - stat: >
        Scroll-driven animations (animation-timeline: scroll() and view()) browser support:
        Chrome 115+ (since December 2024 production-stable), Edge 115+, Safari 26+ (newly
        shipping). Firefox support is in active development under Interop 2026.
      source: "https://caniuse.com/wf-scroll-driven-animations"
    - stat: >
        Popper.js package size: approximately 2 kB minzipped. Floating UI (its successor):
        approximately 600 bytes for the core. Despite their small individual sizes, these
        libraries require JavaScript parsing and execution overhead, plus event listener
        registration for scroll and resize events, costs that are eliminated entirely by CSS
        Anchor Positioning.
      source: "https://blog.logrocket.com/popper-vs-floating-ui/"
    - stat: >
        GSAP npm package size: 6.26 MB (full package). The minified core gsap.min.js is
        approximately 60-72 kB. In contrast, CSS scroll-driven animations require zero
        additional download — they are implemented in the browser engine itself.
      source: "https://bundlephobia.com/package/gsap"
    - stat: >
        Masonry.js is downloaded approximately 200,000 times weekly on npm. CSS native
        masonry layout (grid-lanes / display: masonry) targets eliminating this entire
        dependency category once it reaches cross-browser Baseline.
      source: "https://www.smashingmagazine.com/2025/12/masonry-things-you-wont-need-library-anymore/"
    - stat: >
        The median JavaScript per page in 2025 has grown to 23 requests (up 8% since 2022),
        with total page weight reaching approximately 2 MB. CSS-native replacements for layout
        and animation directly reduce this JS request count.
      source: "https://www.smashingmagazine.com/2025/12/masonry-things-you-wont-need-library-anymore/"

  counterpoints:
    - point: >
        CSS Anchor Positioning still lacks full cross-browser support as of early 2026:
        Firefox support is progressing (Firefox 145+) but some versions still require flags.
        Production sites targeting broad compatibility need either a polyfill (the Floating UI
        team released one) or a progressive enhancement approach that falls back to a simpler
        non-anchored tooltip for unsupported browsers.
      source: "https://caniuse.com/css-anchor-positioning"
    - point: >
        CSS scroll-driven animations have no native Safari support as of early 2026 (Safari 26
        adds support but the rollout to users is gradual). Sites requiring scroll animation in
        Safari still need either GSAP, IntersectionObserver-based fallbacks, or acceptance
        that the animation simply does not run in that browser — creating a two-tier
        experience.
      source: "https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Scroll-driven_animations"
    - point: >
        GSAP and similar JavaScript animation libraries remain superior for complex,
        sequenced, multi-step animations with precise timing control. CSS scroll-driven
        animations excel at single-property transforms tied to scroll position but lack
        the timeline orchestration capabilities that GSAP's ScrollTrigger provides for
        complex storytelling sequences. The 'CSS vs. JS' framing can be misleading for
        advanced use cases.
      source: "https://www.clcreative.co/blog/should-you-use-the-intersection-observer-api-or-gsap-for-scroll-animations"
    - point: >
        State of CSS 2024 data shows that despite years of availability, Cascade Layers have
        only 18.9% adoption, suggesting a pattern: CSS features take 2-3 years after initial
        browser shipping to see widespread production use. Container queries, anchor
        positioning, and scroll-driven animations may follow a similar slow-adoption curve
        regardless of technical readiness.
      source: "https://web.dev/blog/state-of-css-html-2024"
    - point: >
        Purely CSS tooltip and popover patterns using the Popover API and Anchor Positioning
        work well for simple cases but lose flexibility compared to JavaScript libraries
        for dynamic content, programmatic show/hide based on application state, or complex
        trigger logic (e.g., show tooltip after 500ms hover, hide on external click, track
        with animation). JavaScript remains the correct tool when interaction state is
        entangled with application logic rather than pure presentation.
      source: "https://frontendmasters.com/blog/using-the-popover-api-for-html-tooltips/"
    - point: >
        The CSS Grid auto-fill card pattern (repeat(auto-fill, minmax())) is a 3-line solution
        but is not a universal replacement for JavaScript-based dynamic layouts: it does not
        support asymmetric grids, content-driven column spanning, or runtime layout
        recalculation based on data. Masonry layouts, drag-and-drop reordering, and
        data-driven tile sizes still require JavaScript.
      source: "https://css-tricks.com/look-ma-no-media-queries-responsive-layouts-using-css-grid/"

  case_studies:
    - title: "Pattern 1: Sticky Tooltip — JavaScript Popper.js vs CSS Anchor Positioning"
      summary: >
        JavaScript approach (before): Import Popper.js (~2 kB minzipped) or Floating UI
        (~600 bytes), write event listeners to show/hide the tooltip on mouseenter/mouseleave,
        call createPopper() to position the element, add a ResizeObserver and scroll listener
        to update position on layout changes, and handle viewport overflow detection manually.
        Typical implementation: 30-50 lines of JavaScript plus library import.

        CSS approach (after): Mark the trigger element with anchor-name: --my-anchor, give
        the tooltip position: absolute; position-anchor: --my-anchor; position-area: top;
        position-try-fallbacks: flip-block, flip-inline. For show/hide, use the HTML
        popover="hint" attribute with popovertarget on the button — zero JavaScript required.
        Typical implementation: 8-12 lines of CSS + 3 HTML attributes.

        Bundle size delta: Eliminates the Popper.js/Floating UI import entirely. For a site
        that loads Popper.js only for tooltips, this removes ~2 kB of JavaScript. More
        significantly, it removes JavaScript execution cost: no event listener registration,
        no getBoundingClientRect() calculations per scroll frame.

        Production caveat: CSS Anchor Positioning is in Interop 2026; Firefox 145+ and
        Safari 26+ are adding support. For full browser coverage today, use Floating UI's
        CSS Anchor Positioning polyfill as a progressive enhancement bridge.
      source: "https://www.southwellmedia.com/blog/css-2026-7-features-that-let-browsers-do-the-work"

    - title: "Pattern 2: Scroll Reveal Animation — JavaScript IntersectionObserver vs CSS view-timeline"
      summary: >
        JavaScript approach (before): Create a new IntersectionObserver with a callback
        that adds an 'is-visible' CSS class when the element crosses a threshold. Write
        the observer initialization, observe() calls for each target element, and
        disconnect() cleanup. Then write the CSS animation that activates on the added class.
        Typical implementation: 15-25 lines of JavaScript + 10-15 lines of CSS = 25-40 total
        lines across two files.

        CSS approach (after): Use animation-timeline: view() directly on the element with
        animation-range: entry 0% entry 30% to trigger as the element scrolls into view.
        No JavaScript required. The CSS @keyframes define the reveal effect and the
        animation-timeline property ties it to viewport intersection.
        Typical implementation: 8-12 lines of CSS, single file.

        Performance delta: JavaScript-based IntersectionObserver runs on the main thread.
        CSS scroll-driven animations run on the compositor thread (GPU), remaining smooth
        even when the main thread is busy processing JavaScript. Chrome's performance case
        study demonstrated that CSS scroll animations are 'completely unaffected by heavy
        JavaScript work' running concurrently, whereas JS animations become janky under
        the same conditions.

        For homepage use: fade-in cards, reveal text sections, progress bars, and
        parallax effects are all achievable with CSS view-timeline in Chrome/Edge today.
        Use a fallback for Safari/Firefox: either accept no animation (graceful degradation)
        or detect support with @supports (animation-timeline: scroll()) and provide a
        static fallback.
      source: "https://www.smashingmagazine.com/2024/12/introduction-css-scroll-driven-animations/"

    - title: "Pattern 3: Responsive Card Grid — JavaScript Viewport Listener vs CSS Grid auto-fill"
      summary: >
        JavaScript approach (before): Listen to window resize events (debounced), calculate
        the available container width, set a class or inline style to control the number of
        columns, handle SSR mismatch in React/Next.js frameworks, and clean up the listener
        on component unmount. Typical implementation: 20-40 lines of JavaScript.

        CSS approach (after): grid-template-columns: repeat(auto-fill, minmax(280px, 1fr))
        is the complete responsive logic. One property, one line. The browser calculates
        column count automatically as the container resizes — no JavaScript required.
        Add grid-gap: 1.5rem for gutters. Total implementation: 3-4 lines of CSS.

        Bundle size delta: Eliminates all JS for this pattern. No resize event listener,
        no debounce utility, no class-manipulation logic. The savings are modest in absolute
        bytes but the removal of JS execution on every resize event improves input
        responsiveness.

        Line count comparison: ~30 lines JavaScript + ~15 lines CSS (with breakpoint media
        queries) = 45 total lines DOWN TO ~4 lines CSS with no media queries needed.
        CSS-Tricks documented this as a 'magical one-liner' for the core column behavior.

        Limitation: auto-fill/auto-fit does not support intentionally asymmetric layouts
        (e.g., a featured card that spans 2 columns and 3 regular cards). Container queries
        (container-type: inline-size) expand this, allowing individual card components to
        respond to their container width without viewport media queries.
      source: "https://css-tricks.com/look-ma-no-media-queries-responsive-layouts-using-css-grid/"

    - title: "Smashing Magazine: Carousel Navigation — 100% CSS with ::scroll-marker"
      summary: >
        Smashing Magazine's 'CSS Wrapped 2025' documented that the ::scroll-marker and
        ::scroll-button() pseudo-elements enable a fully functional, accessible carousel
        slider with navigation dots and forward/back buttons written entirely in CSS.
        Previously, this pattern required a JavaScript library (Swiper.js, Slick Carousel,
        Embla) with significant bundle weight, event listener management, and accessibility
        handling. The CSS approach uses native scroll snapping combined with the new
        pseudo-elements, with the browser providing accessibility semantics automatically.
        Smashing's editorial framing: 'The ability to create a fully functional, accessible
        slider without a single line of JavaScript is not just convenient; it is a triumph
        for performance.'
      source: "https://www.smashingmagazine.com/2025/12/state-logic-native-power-css-wrapped-2025/"

    - title: "LogRocket: The 150+ Line JavaScript-to-CSS Demo"
      summary: >
        LogRocket demonstrated that a customizable component combining staggered animations,
        automatic positioning, data-driven theming, and keyboard navigation — previously
        requiring 150+ lines of JavaScript — can be built with CSS using appearance: base-select
        for native select styling, sibling-index() for staggered animations, typed attr() for
        reading data-* color attributes directly into CSS values, and the Popover API for
        accessible focus management. The result replaces the JavaScript entirely while
        delivering built-in accessibility (keyboard navigation, focus management, ARIA
        semantics) that was previously the most complex part of the JavaScript implementation.
      source: "https://blog.logrocket.com/css-in-2026/"

    - title: "Sticky Header Shadow: CSS scroll-state Query vs JavaScript IntersectionObserver"
      summary: >
        A concrete homepage pattern: a sticky navigation header should gain a drop-shadow
        only when the user has scrolled past the hero section. JavaScript approach requires
        creating an IntersectionObserver watching a sentinel element at the top of the page,
        calling classList.add('is-sticky') in the callback, and writing CSS to show the
        shadow on the .is-sticky class — approximately 15-20 lines of JavaScript.

        CSS approach (2025+) using scroll state queries: @container scroll-state(stuck: top)
        { nav { box-shadow: 0 2px 8px rgba(0,0,0,0.15); } } — two lines of CSS. The
        container-type: scroll-state property on the scroll container enables this query.
        Smashing Magazine highlights this as one of the most practically impactful CSS
        features for homepage design in 2025.
      source: "https://www.smashingmagazine.com/2025/12/state-logic-native-power-css-wrapped-2025/"
